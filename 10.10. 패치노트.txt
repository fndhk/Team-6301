🚀 추가 개발 업데이트 및 패치노트
팀원 여러분께, 10월 9일자 공유 이후 진행된 추가 개발 내역을 공유합니다. 이번 업데이트에서는 리듬 판정 시스템과 아이템 드래그 앤 드롭 등 게임의 핵심적인 상호작용 기능들이 완성되었습니다.

✨ 신규 기능 및 스크립트
리듬 판정 시스템 (JudgmentManager.cs)
타워의 공격이 RhythmManager의 비트와 얼마나 정확히 일치하는지 시간 오차(Time Error)를 계산하여 **"Perfect", "Great", "Good", "Miss"**로 판정하는 핵심 시스템입니다.

판정 결과에 따라 데미지 보너스를 차등 적용하며, 타워 위치에 판정 결과를 UI 텍스트로 표시하여 시각적 피드백을 제공합니다.

싱크 보너스 (Sync Bonus) 시스템
JudgmentManager에 통합된 기능으로, 2개 이상의 타워가 같은 비트 내에 동시에 "Perfect" 판정을 받으면 발동합니다.

싱크 보너스 달성 시 ScoreManager를 통해 추가 보너스 점수를 획득합니다.

아이템 드래그 앤 드롭 시스템 (DragDropManager.cs 등)
이제 인벤토리의 아이템을 마우스로 끌어 타워 슬롯 위치에 놓을 수 있습니다.

InventorySlot.cs에 드래그 이벤트 핸들러(IBeginDragHandler 등)가 구현되었고, DragDropManager.cs가 마우스를 따라다니는 아이콘을 관리합니다.

✏️ 주요 변경 및 개선 사항
타워 시스템 구조 변경 (상속 기반 리팩토링)
기존 Tower.cs가 모든 타워의 공통 기능을 담는 추상 클래스 **BaseTower.cs**로 변경되었습니다.

이를 상속받는 3개의 전문화된 타워 클래스가 구현되었습니다.

PianoTower.cs: 단일 대상 공격

DrumTower.cs: 범위(AoE) 공격

CymbalTower.cs: 적들 사이를 튕기는 공격

타워 배치 및 활성화 방식 변경
"아이템으로 빈 슬롯에 타워 생성" 방식에서 **"미리 배치된 비활성 타워를 아이템으로 활성화"**하는 방식으로 시스템 전체를 재설계했습니다.

이에 따라 TowerSlot.cs의 역할이 타워 생성 관리에서, 이미 존재하는 타워의 상태(활성화/비활성화)를 관리하는 역할로 변경되었습니다.

공격 및 판정 매커니즘 변경
BaseTower의 공격 방식이 RhythmManager의 박자 이벤트에 직접 따르는 방식에서, 자체 공격 속도(fireRate) 타이머를 갖는 방식으로 롤백되었습니다.

대신, 공격이 발생하는 시간(Time.time)을 JudgmentManager에 전달하여, RhythmManager의 비트 시간과 비교 후 정밀하게 판정받는 구조로 변경되었습니다.

점수 시스템 확장 및 개선
ScoreManager에 리듬 판정(AddRhythmScore)과 싱크 보너스(AddSyncBonusScore) 점수를 추가하는 기능이 구현되었습니다.

단순화되었던 '처치 점수'에 '타워와의 거리에 따른 보너스' 기능이 다시 부활했습니다.

Enemy.cs의 TakeDamage 함수가 공격자(damageSource)의 정보를 받도록 개선되어, 사망 시 공격한 타워와의 거리를 정확히 계산할 수 있게 되었습니다.

-------------------------------------------------------------------------------------------------------------------------
📝 최신 버전 개발 가이드
🆕 새로운 종류의 타워를 추가하고 싶을 때
🗣️ "새로운 '기타' 타워를 만들어서, 3연사 공격을 하게 하고 싶어요."

이제 상속 구조가 잡혀있어 새로운 타워를 추가하는 것이 매우 쉬워졌습니다.

스크립트 생성: BaseTower.cs를 상속받는 새로운 스크립트(예: GuitarTower.cs)를 만듭니다.

C#

public class GuitarTower : BaseTower
{
    // 이 안에 기타 타워만의 고유한 로직을 작성합니다.
    public override void Attack(int finalDamage)
    {
        // 3연사 공격 로직 구현 (예: 코루틴 호출)
    }
}
프리팹(Prefab) 제작:

타워의 외형을 만들고, 방금 만든 GuitarTower.cs 스크립트를 붙여줍니다.

Inspector 창에서 Base Damage, Fire Rate 등 BaseTower의 기본 능력치를 설정하고, GuitarTower만의 고유 변수(필요하다면)를 설정합니다.

완성된 오브젝트를 Project 창으로 드래그하여 프리팹으로 저장합니다.

씬(Scene)에 배치:

Hierarchy에서 빈 GameObject로 슬롯(예: Slot_Guitar)을 만듭니다.

새로 만든 GuitarTower 프리팹을 그 슬롯의 자식으로 배치하고, 처음에는 비활성화(SetActive(false))합니다.

부모 슬롯 오브젝트에 TowerSlot.cs 스크립트와 BoxCollider2D를 추가하고, Tower In Slot 변수에 자식인 GuitarTower를 연결합니다.

⚖️ 리듬 판정 및 점수를 조절하고 싶을 때
🗣️ "'Perfect' 판정을 더 쉽게 만들고 싶어요."
🗣️ "싱크 보너스 점수를 더 높이고 싶어요."

모든 판정 및 리듬 관련 점수는 두 개의 매니저에서 쉽게 조절할 수 있습니다.

핵심 파일: JudgmentManager.cs, ScoreManager.cs

방법:

판정 난이도/데미지 배율: JudgmentManager 오브젝트의 Inspector 창에서 Perfect Window 값을 늘리면 판정이 너그러워지고, Perfect Multiplier 값을 조절하면 데미지 보너스가 변경됩니다.

점수: ScoreManager 오브젝트의 Inspector 창에서 Perfect Score, Great Score, Sync Bonus Score 값을 직접 수정하여 각 판정 및 보너스 점수를 조절할 수 있습니다.

↔️  아이템의 상호작용을 변경하고 싶을 때
🗣️ "아이템을 타워에 놓았을 때 버프 대신 다른 효과를 주고 싶어요."

모든 드래그 앤 드롭 상호작용은 TowerSlot.cs에서 최종적으로 처리됩니다.

핵심 파일: TowerSlot.cs

방법: OnItemDropped(ItemData droppedItem) 함수를 수정합니다. 이 함수 안에서, droppedItem.itemType 등을 확인하는 if 또는 switch 문을 추가하여, 특정 아이템일 때 다른 함수를 호출하거나 특별한 로직을 실행하도록 확장할 수 있습니다.

平衡 게임 밸런스(능력치)를 조절하고 싶을 때 (업데이트)
🗣️ "피아노 타워의 기본 공격력을 낮추고 싶어요."
🗣️ "드럼 타워의 공격 속도를 빠르게 하고 싶어요."

타워 프리팹: 각 타워의 프리팹(예: PianoTower.prefab)을 선택하고 Inspector 창을 봅니다. BaseTower 섹션에 있는 **Base Damage**와 Fire Rate 값을 직접 수정하여 개별 타워의 기본 능력치를 조절합니다. 

JudgmentManager.cs: 리듬 판정에 따른 데미지 배율 자체를 변경하고 싶다면, JudgmentManager 오브젝트의 Inspector 창에서 Perfect Multiplier 등의 값을 수정합니다.


적 프리팹: 수정하고 싶은 적 프리팹을 선택하고 Inspector 창의 Enemy (Script) 컴포넌트에서 Max Health, Speed 등을 수정합니다. 

✨ 새로운 아이템이나 버프를 추가하고 싶을 때 (업데이트)
🗣️ "타워의 사정거리를 늘려주는 아이템을 만들고 싶어요."

ItemData.cs 수정: EffectType 이라는 enum에 AttackRange와 같은 새로운 효과 종류를 추가합니다.


ItemData 애셋 생성: Project 창에서 Create → Inventory → Item 메뉴를 통해 새 아이템 애셋을 만들고, Item Type은 Buff, Effect Type은 방금 만든 AttackRange로 설정합니다. 

BaseTower.cs 수정: 사정거리를 변경하는 새로운 함수(예: public void ApplyRangeBuff(...))를 추가합니다.

TowerSlot.cs 수정: OnItemDropped 함수에 AttackRange 효과 타입을 확인하는 else if 구문을 추가하고, towerInSlot의 ApplyRangeBuff 함수를 호출하도록 연결합니다.